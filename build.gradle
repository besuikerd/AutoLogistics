buildscript {
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2-SNAPSHOT'
        classpath 'org.ajoberstar:grgit:1.3.0'
    }
}

repositories {
    maven {
        name = "chickenbones"
        url = "http://chickenbones.net/maven/"
    }

    ivy {
        name "CoFHLib"
        artifactPattern "http://addons-origin.cursecdn.com/files/2243/944/[module]-[revision].[ext]"
    }
    ivy {
        name "CoFHCore"
        artifactPattern 'http://addons-origin.cursecdn.com/files/2243/947/[module]-[revision].[ext]'
    }
    ivy {
        name "ThermalExpansion"
        artifactPattern "http://addons-origin.cursecdn.com/files/2233/797/[module]-[revision].[ext]"
    }
    ivy {
        name "ThermalFoundation"
        artifactPattern "http://addons-origin.cursecdn.com/files/2243/149/[module]-[revision].[ext]"
    }

    ivy {
        name "ThermalDynamics"
        artifactPattern "http://addons-origin.cursecdn.com/files/2244/301/[module]-[revision].[ext]"
    }
}

apply plugin: 'groovy'
apply plugin: 'scala'
apply plugin: 'idea'
apply plugin: 'forge'
apply plugin: 'curseforge'

sourceSets {
    main {
        java {
            srcDirs = []
        }
        scala {
            srcDir "src/main/java"
        }
        resources{
            srcDir "buildSrc/src/main/groovy"
        }
    }
    test {
        java {
            srcDirs = []
        }
        scala{
            srcDir "src/test/java"
        }
    }
}

sourceCompatibility = '1.6'
targetCompatibility = '1.6'

apply plugin: LoadPropertiesPlugin

def File buildConfigFile = file('conf/buildConfig.properties')
def Properties buildConfig = loadProperties buildConfigFile


version = buildConfig.version
group = buildConfig.group
archivesBaseName = buildConfig.modName
def File configFile = file('conf/config.properties')
def Properties config = loadProperties configFile
def Properties privateProperties = loadProperties file('conf/private.properties')

minecraft {
    version = "$buildConfig.forgeVersion-$buildConfig.minecraftVersion"
    runDir = "minecraft"

    println("buildConfig: $buildConfig")

    buildConfig.each{ entry ->
        replace "@$entry.key@", entry.value
    }
}


configurations.create('mod')
configurations.mod {
    description = 'mod dependencies'
    transitive = true
}

dependencies {
    compile gradleApi()

    compile "codechicken:CodeChickenCore:1.7.10-1.0.4.29:src"
    compile "codechicken:NotEnoughItems:1.7.10-1.0.3.74:src"
    mod "codechicken:CodeChickenCore:1.7.10-1.0.4.29:dev"
    mod "codechicken:NotEnoughItems:1.7.10-1.0.3.74:dev"

    compile group: 'cofh', name: 'CoFHLib', version: '[1.7.10]1.0.3B1-164-dev', ext: 'jar'
    compile group: 'cofh', name: 'CoFHCore', version: '[1.7.10]3.0.2-284-dev', ext: 'jar'
    compile group: 'cofh', name: 'ThermalExpansion', version: '[1.7.10]4.0.0-176-dev', ext: 'jar'
    compile group: 'cofh', name: 'ThermalFoundation', version: '[1.7.10]1.0.0-88-dev', ext: 'jar'
    compile group: 'cofh', name: 'ThermalDynamics', version: '[1.7.10]1.0.0-137-dev', ext: 'jar'

    testCompile 'org.scalatest:scalatest_2.11:2.2.5'
    testCompile 'junit:junit:4.12'
}

task cleanMods << {
    deleteMods.execute()
    copyMods.execute()
}

task deleteMods(type:Delete){
    delete fileTree("${minecraft.runDir}/mods").include('*')
}

task copyMods(type:Copy) {
    into "${minecraft.runDir}/mods/"
    from configurations.mod
}

processResources
{
    // this will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
                
        // replace version and mcversion
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }
        
    // copy everything else, thats not the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }


}


def executeCommand(String command){
    def args = command.split(/(?<!\\) /)
    def windowsArgs = new String[args.length + 2];
    windowsArgs[0] = 'cmd'
    windowsArgs[1] = '/c'
    System.arraycopy(args, 0, windowsArgs, 2, args.length)

    task execute(type:Exec, overwrite:true){
        if(System.getProperty('os.name').startsWith('Windows')){
            commandLine windowsArgs
        } else{
            commandLine args
        }
        standardOutput = new ByteArrayOutputStream()

        ext.output = {
            return standardOutput.toString()
        }
    }
    execute.execute()
    return execute.ext.output()
}


def latestHash = new LazyValue({return executeCommand("git rev-parse HEAD").trim()})
def changeLog = new LazyValue({
    def cmd = "git log --pretty=\"  *%s\" $config.lastBuildHash...HEAD"
    return executeCommand(cmd)
})

task incrementBuildNumber << {
    if(!config.lastBuildHash.equals(latestHash())){
        if(config.lastBuildHash != latestHash()){
            buildConfig.buildNumber++
            buildConfig.version = "$buildConfig.majorVersion.$buildConfig.majorVersion.$buildConfig.buildNumber".toString()
            if(!buildConfig.releaseType.equals("release")){
                buildConfig.version = "$buildConfig.version-$buildConfig.releaseType".toString()
            }

            ant.propertyfile(file:buildConfigFile){
                entry(key: 'buildNumber', value: buildConfig.buildNumber)
                entry(key: 'version', value: buildConfig.version)
            }
        }
    }
}

task updateChangelog(dependsOn: incrementBuildNumber) {
    doLast{
        if(changeLog().isEmpty()) {
            throw new StopExecutionException("SKIPPED")
        } else {
            def StringBuilder decoratedChangelog = new StringBuilder()
            decoratedChangelog.append("version $buildConfig.version:\n")
            decoratedChangelog.append(changeLog())
            decoratedChangelog.append("\n\n")

            def changeLogFile = new RandomAccessFile(config.changeLogFile, "rws")

            def byte[] contents = new byte[changeLogFile.length()]
            try {
                changeLogFile.readFully(contents)
                changeLogFile.seek(0)
                changeLogFile.write(decoratedChangelog.toString().getBytes())
                changeLogFile.write(contents)
            } finally {
                changeLogFile.close()
            }
        }
    }
}

task updateLatestHash(dependsOn: updateChangelog) {
    if(!config.lastBuildHash.equals(latestHash())){
        ant.propertyfile(file:configFile){
            entry(key: 'lastBuildHash', value: latestHash())
        }
    }
}


task sourceJar(type: Jar) {
    from sourceSets.main.java
    from sourceSets.main.scala
    classifier = 'src'
}

task devJar(type: Jar) {
    from sourceSets.main.output
    classifier = 'dev'
}

artifacts{
    archives sourceJar, devJar
}

curse {
    projectId = config.curseForgeProjectId
    apiKey = privateProperties.curseForgeApiKey
    addGameVersion buildConfig.minecraftVersion
    releaseType = buildConfig.releaseType
    additionalArtifact devJar
    additionalArtifact sourceJar
    changelog = changeLog()
}

curse.dependsOn(updateChangelog)
updateLatestHash.mustRunAfter(curse)